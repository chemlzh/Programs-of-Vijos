#include <cstdio>
long n, tmp, tb1, tb2, b[1505];
int main() {
	scanf("%ld", &n);
	for (long i = 1; i <= n; i++) {
		scanf("%ld", &tb1), b[i] = tb1 - tb2, tb2 = tb1, tmp = i;
		while (!b[tmp]) tmp--;
		printf("%ld ", i - tmp + 1);
		b[tmp]--;
	}
}
/*
思路：这道题可以用栈模拟来解决，将男孩和女孩均编为1到n号，且i号女孩左边的男孩有a[i]个，
则当i号女孩的舞伴正好在该女孩的左边，则有a[i]=男孩的编号，
而由于一对舞伴之间有且只有k(k=0, 1, ...)对舞伴，且没有人落单，
因此若i号女孩的舞伴与该女孩之间有k对舞伴，则夹在这对舞伴之间的男孩有k个，
从而有a[i]=男孩的编号+k. 相应的，这对舞伴的距离为(k+1)=a[i]-男孩的编号+1.
我们可以让元素1到n进栈，进栈的规律为：
对i号女孩，将(top元素编号+1)至a[i]的元素全部进栈（若尚未进入），
特别的，若栈为空，则进栈元素为1至a[i]，
然后将top元素取出，则这对舞伴的距离为a[i]-top元素编号+1.
*/

/*
栈的写法可以改成线性表的写法，也即记b[i]为i号女孩与(i-1)号女孩间隔的（尚未匹配的）男孩个数，
由前可知，初始时b[i]代表i号女孩与(i-1)号女孩间隔的舞伴个数
若b[i]不为零，则i号女孩与邻近的男孩直接配对，此时b[i]减一，
否则表明i号女孩与(i-1)号女孩之间没有（尚未匹配的）男孩，而由前可知舞伴之间的人没有落单，
故(i-1)号女孩已经匹配，此时向左搜寻使b[i]不为零的i值，则(i始-i末)即为这对舞伴间隔的舞伴对数，
而这对舞伴的距离即为(i始-i末+1).
*/